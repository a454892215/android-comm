ClassLoader:java类加载器，功能是把java编译后的字节码文件加载到内存当中。
classLoad加载java字节码文件，一般有7个流程：
1.加载：1. 把类加载到内存中，生产对应的类对象, 2.把静态储存结构转化为方法区运行时的数据结构？
2.验证：严重字节码文件是否符合对应版本的java虚拟机规范
3.准备：初始化静态变量，分配内存
4.解析：把常量池中的符号引用转化为直接引用
5.初始化类的静态变量：
6.使用
7.卸载
Classloader类型从加载优先级类型分为：
启动ClassLoader
扩展classloader
appClassloader
自定义ClassLoader
加载机制：双亲委托机制，优先看上级classLoader是否可以加载，不可以加载则自己加载，依次递归。


JVM内存结构：
1. 方法区：最小16M，最大64M，储存类信息和静态变量信息，各个线程共享内存区域
          运行时常量池是方法区的一部分
2. java方法虚拟机栈：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表，声明周期与线程相同，是线程私有的
3. 本地方法栈：虚拟机栈基本类似，只为native方法
4. 程序计数器：是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器
5. 堆：一般new关键词创建对象所分配的内存区域叫做堆，堆是由所有线程共享的,所以需要加锁保证不冲突，
      因此性能没有栈性能好。
      堆内存分配策略优先级：栈->TLAB（Thread Local Allocation Buffer 也属于堆比较特殊）->年老代分配->eden分配
       JVM在Server模式下的逃逸分析可以分析出某个对象是否永远只在某个方法、线程的范围内->使用栈分配
       对象内存分配的两种方法：1.指针碰撞 2. 空闲列表
       哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用
       的垃圾收集器是否带有压缩整理功能决定。
  Java虚拟机的堆内存中，主要分为年轻代和老年代两个部分。而在年轻代中，又可以细分为Survivor区，Eden区、From区和To区：
  Eden区是年轻代中最大的一个区域，用于存放新创建的对象。当一个对象被创建时，首先会被分配到Eden区
  年轻代堆内存用来存放新近创建的对象：使用minorGC回收->年轻代对象在进过minorGC后可能进入老年代堆内存区域
  老年代堆内存主要存放应用程序中生命周期长的内存对象。->使用majorGC回收



  Java设计模式根据其解决的问题和应用场景，通常分为三大类：
  创建型模式（Creational Patterns）:单例模式, 工厂方法模式, 抽象工厂模式,建造者模式,原型模式
  结构型模式（Structural Patterns）:适配器模式, 桥接模式, 组合模式, 装饰器模式, 外观模式, 享元模式, 代理模式
  行为型模式（Behavioral Patterns）:职责链模式, 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式
  每一类模式侧重于解决特定类型的问题，并提供不同的方法来设计和实现灵活且可扩展的系统。
