Java设计模式根据其在软件开发中的目的和应用场景，通常分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）和行为型模式（Behavioral Patterns）。这种分类基于设计模式在软件系统中解决问题的不同方式和所涉及的设计关注点。

创建型模式（Creational Patterns）
创建型模式主要关注对象的创建过程，目的是将对象的创建过程与系统使用对象的过程分离。这类模式帮助创建对象的同时，隐藏创建逻辑，并且可以根据需要灵活地更改创建的对象类型。常见的创建型模式包括：

单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点。
工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。它使一个类的实例化延迟到其子类。
抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建相关或依赖对象的家族，而无需明确指定具体类。
建造者模式（Builder Pattern）：将一个复杂对象的构建与其表示分离，使同样的构建过程可以创建不同的表示。
原型模式（Prototype Pattern）：通过复制现有对象来创建新对象，而不是从头开始创建。
结构型模式（Structural Patterns）
结构型模式主要关注类和对象的组合或结构，以便构建更大、更复杂的结构。这类模式帮助确保在类和对象之间建立正确的关系，并且通常通过继承或接口实现来组合对象。常见的结构型模式包括：

适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另一个接口，使得原本因接口不兼容而不能一起工作的类可以协同工作。
桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得客户端可以统一地处理单个对象和组合对象。
装饰器模式（Decorator Pattern）：动态地给对象添加职责，通过创建一个装饰类包装原始类，使得这些职责可以叠加。
外观模式（Facade Pattern）：为子系统中的一组接口提供一个一致的界面，使得子系统更容易使用。
享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度对象的复用。
代理模式（Proxy Pattern）：为其他对象提供一种代理以控制对这个对象的访问。
行为型模式（Behavioral Patterns）
行为型模式主要关注对象之间的通信和职责分配。这类模式描述了对象之间的交互方式以及职责的划分方式，从而帮助提高系统的灵活性和可扩展性。常见的行为型模式包括：

职责链模式（Chain of Responsibility Pattern）：为请求创建一个接收对象的链，使得多个对象都有机会处理该请求，从而避免请求的发送者和接收者之间的耦合。
命令模式（Command Pattern）：将请求封装成一个对象，从而使用户使用不同的请求、队列或日志来参数化其他对象。
解释器模式（Interpreter Pattern）：给定一种语言，定义它的文法表示，并定义一个解释器来处理这种文法。
迭代器模式（Iterator Pattern）：提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部表示。
中介者模式（Mediator Pattern）：用一个中介对象封装一系列对象之间的交互，使对象之间不需要显式地相互引用，从而使它们可以松散耦合。
备忘录模式（Memento Pattern）：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
观察者模式（Observer Pattern）：定义对象间的一对多依赖关系，使得每当一个对象改变状态时，其相关依赖对象都会收到通知并自动更新。
状态模式（State Pattern）：允许一个对象在其内部状态改变时改变其行为，使对象看起来好像修改了其类。
策略模式（Strategy Pattern）：定义一系列算法，将每一个算法封装起来，并使它们可以互换。
模板方法模式（Template Method Pattern）：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重新定义算法的某些特定步骤。
访问者模式（Visitor Pattern）：表示一个作用于某对象结构中的各元素的操作，使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。