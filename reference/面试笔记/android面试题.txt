## Android 面试题清单

### 一、Java/Kotlin 基础
1. **Java 内存模型与垃圾回收**
   - 简述 JVM 内存分区（堆、栈、方法区等）
   - GC 原理与回收算法（标记清除、复制、分代收集）
   - 如何避免内存泄漏？

2. **面向对象与设计模式**
   - 抽象类与接口的区别
   - 单例模式的实现方式（双重检查、静态内部类）
   - 观察者模式在 Android 中的应用

3. **Kotlin 特性**
   - `val` 与 `var` 的区别
   - 扩展函数、高阶函数与 Lambda
   - 协程原理：`suspend` 函数如何工作？

### 二、Android 核心组件
1. **Activity**
   - 生命周期及其对应场景
   - `onSaveInstanceState()` 与 `onRestoreInstanceState()` 调用时机
   - Activity 启动模式（standard、singleTop 等）

2. **Fragment**
   - 生命周期与 Activity 生命周期的关联
   - Fragment 之间通信方式
   - 为什么 Fragment 推荐使用 `setArguments()` 传递数据？

3. **Service**
   - Service 与 IntentService 的区别
   - 前台服务与后台服务的限制（Android 8.0+）
   - 绑定服务（Bound Service）的实现方式

4. **BroadcastReceiver**
   - 有序广播与无序广播的区别
   - 本地广播（LocalBroadcastManager）的优势

5. **ContentProvider**
   - 如何实现跨进程数据共享？
   - `UriMatcher` 的作用是什么？

### 三、UI 与布局
1. **View 系统**
   - View 绘制流程：`measure()` → `layout()` → `draw()`
   - 事件分发机制：`onTouchEvent()`、`onInterceptTouchEvent()`
   - 自定义 View 的关键步骤

2. **布局优化**
   - 如何减少布局层级？
   - ConstraintLayout 的优势
   - `include`、`merge`、`ViewStub` 的作用

3. **RecyclerView**
   - 缓存机制（Scrap、Recycle、ViewCacheExtension）
   - 如何实现多类型列表？
   - DiffUtil 的原理与优势

### 四、多线程与异步处理
1. **线程管理**
   - Handler、Looper、MessageQueue 的工作原理
       Handler把消息发送到 MessageQueue
       Looper不断到从MessageQueue里面取出消息执行
   - AsyncTask 的缺陷与替代方案
       ：AsyncTask 不绑定 Activity/Fragment 生命周期，后台任务可能在界面销毁后仍然运行，容易 内存泄漏
   - 如何在子线程更新 UI？
        主线程的Handle ，发送 runable,在runable中更新UI

2. **线程安全**
   - `synchronized` 与 `ReentrantLock` 的区别
   - volatile 关键字的作用： 保证写后 其他线程马上可以更新，不会读取到旧的值
   - 使用 Atomic 类避免竞态条件

### 五、数据存储
1. **SharedPreferences**
   - 适用场景与性能问题
   - `apply()` 与 `commit()` 的区别

2. **SQLite**
   - 数据库升级策略
   - 事务的使用与优势

3. **Room**
   - 三大组件（Entity、DAO、Database）
   - 数据库迁移示例

### 六、网络与通信
1. **HTTP/HTTPS**
   - GET 与 POST 的区别
   - HTTPS 握手过程

2. **网络框架**
   - OkHttp 拦截器链原理
        OkHttp 的拦截器链，其实就是 责任链模式（Chain of Responsibility）：
        责任链模式：串行顺序处理，中间可以拦截或者直接返回，
        拦截器通过 intercept(Chain chain) 处理请求和响应
        通过 chain.proceed(request) 递归调用下一个拦截器
        可分为应用拦截器和网络拦截器，前者不受缓存/重试影响，后者紧贴网络
        链尾由 CallServerInterceptor 发起真实请求，返回响应沿链回溯
   - Retrofit 动态代理实现原理

3. **数据解析**
   - Gson 反序列化泛型擦除问题如何解决？
         Gson 提供 TypeToken<T> 来保留泛型类型信息：
   - 如何优化 JSON 解析性能？
     库的选择：树解析，流式解析，按需解析 / 延迟解析

### 七、性能优化
1. **内存优化**
   - 内存泄漏检测（LeakCanary 原理）
         ：也就是LeakCanary只是监控少数对象（view, activity,fragment），然后根据他们的生命周期状态，确认是否内存泄露。
   - 图片加载优化（Bitmap 压缩、缓存策略）
         1. BitmapFactory.Options.inSampleSize 按比例缩小图片
         2. 配置合适的 Bitmap.Config  默认 Bitmap.Config.ARGB_8888，占用 4 字节/像素  如果不需要透明，可用 RGB_565（2 字节/像素），节省50%
         3. 使用webp
         4.多级缓存机制
         5.异步加载

2. **启动优化**
   - 冷启动、温启动、热启动的区别
   - 如何优化 Application 初始化？
     ： Application 太臃肿主要是因为所有 SDK、业务模块都在 onCreate() 初始化。
       延迟初始化（Lazy Init）
       异步初始化（background init）
       尽量减少住线程的耗时操作

3. **APK 瘦身**
   - 资源混淆（AndResGuard）
   - 如何减少方法数？：Android 方法数上限：单个 DEX 文件65536， 开启 R8/ProGuard 混淆
                    R8 主要执行：
                    删除无用类、无用方法、无用字段
                    方法内联（inline）
                    常量折叠
                    类合并、方法合并
                    移除泛型、调试信息等
     编译期扫描所有资源
     对资源名进行重命名（短字符）
     删除 unused 资源
     压缩图片
     重新生成 R 类映射

### 八、架构与设计
1. **MVC、MVP、MVVM**
   - MVP 中 Presenter 与 View 如何解耦？
   - ViewModel 如何实现数据持久化？： SavedStateHandle， DataStore
   - DataBinding 的双向绑定原理

2. **组件化**
   - 模块间通信（ARouter 原理）
   - 如何避免资源冲突？

3. **依赖注入**
   - Dagger2/Hilt 的核心注解（@Module、@Component）

### 九、开源框架原理
1. **Glide**
   - 三级缓存机制
   - 如何与生命周期绑定？

2. **RxJava**
   - 观察者模式实现
   - 背压策略（Backpressure）

### 十、新技术
1. **Jetpack Compose**
   - 声明式 UI 与命令式 UI 的区别
   - 重组（Recomposition）机制

2. **Kotlin Multiplatform**
   - 如何共享业务逻辑代码？

### 十一、算法与数据结构（常考）
1. 链表反转
2. 二叉树遍历（前序、中序、后序）
3. 排序算法（快速排序、归并排序）
4. 查找算法（二分查找）

### 十二、开放性问题
1. 如何设计一个图片加载框架？
2. 如何实现断点续传？
3. 如何监控应用的 ANR 和 Crash？

### 面试建议：
- **深度优先**：对 2-3 个核心技术点深入研究
- **项目结合**：用实际项目经验解释原理
- **代码能力**：准备手写代码（算法/自定义 View）
- **最新动态**：关注 Android 14/15 新特性

根据面试公司业务方向（电商、音视频、IoT 等），可针对性加强对应领域知识。祝面试顺利！