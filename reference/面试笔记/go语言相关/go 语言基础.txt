1. 变量声明 var,:=：编译期不确定可以确定的值
   未使⽤用局部变量会引发编译错误。
   var x int
   var f float32 = 1.6
   var x, y, z int
   var s, n = "abc", 123
   s, y := "hello", 20  （短变量声明或赋值）
   :=  短变量申明符号：   同一作用域内，:= 左边必须至少有一个新变量

2. 常量声明const：常量值必须是编译期可确定的数字、字符串、布尔值。
   未使⽤用局部常量不会引发编译错误。
   在常量组中，如不提供类型和初始化值，那么视作与上⼀一常量相同。
   const (
    s = "abc"
    x // x = "abc"
   )
   枚举：关键字 iota 定义常量组中从 0 开始按⾏行计数的⾃自增枚举值。
   const (
    Sunday = iota // 0
    Monday // 1，通常省略后续⾏行表达式。
    Tuesday // 2
    Wednesday // 3
    Thursday // 4
    Friday // 5
    Saturday // 6
   )
   省略表达式时，完整继承上一行， iota 在 const 块中每一行 +1
   const (
    _ = iota // iota = 0
    KB int64 = 1 << (10 * iota) // iota = 1
    MB // 与 KB 表达式相同，但 iota = 2
    GB
    TB
   )
   省略表达式时，完整继承上一行，iota 在 const 块中每一行 +1
   const (
       A, B = iota, iota << 10 // 0, 0 << 10
       C, D                   // 1, 1 << 10
   )
   如果 iota ⾃自增被打断，须显式恢复。显示恢复 也是会继承原本进度的。
   const (
    A = iota // 0
    B // 1
    C = "c" // c
    D // c，与上⼀一⾏行相同。
    E = iota // 4，显式恢复。注意计数包含了 C、D 两⾏行。
    F // 5
   )
3. 类型声明type： 声明类型，声明结构图
 type Color int

如果按官方的“基本类型”计数：总共 17 种基本类型
 | 类别  | 类型数量 | 类型                                                                                |
 | --- | ---- | --------------------------------------------------------------------------------- |
 | 布尔  | 1    | bool                                                                              |
 | 整数  | 11   | int, int8, int16, int32, int64, uint, uint8/byte, uint16, uint32, uint64, uintptr |
 | 浮点  | 2    | float32, float64                                                                  |
 | 复数  | 2    | complex64, complex128                                                             |
 | 字符串 | 1    | string

make:  用于**初始化引用类型**，返回的是一个**已经准备好使用的对象**，而不是零值。
       语法： make(type, len, cap)
   引用类型**包括：
   1. `slice`（切片）：[]int、[]string、[]MyStruct
   2. `map`（映射） ：map[string]int 表示类似Java的Map数据结构，其中string是key的类型，int是值的类型
   3. `chan`（通道）  ch := make(chan int, 3) // 带缓冲区的通道
   注意:`make` **只能用于引用类型, 不能用于数组、结构体或基本类型**（这些用 `var` 或字面量初始化）

new: 分配内存，返回类型的指针，并把内存初始化为零值 p := new(T)
     p := new(int)
     fmt.Println(*p) // 0
     *p = 100
     fmt.Println(*p) // 100

数字类型转换: 不⽀支持隐式类型转换，即便是从窄向宽转换也不⾏,但是可以显试转换。
  var b byte = 100
  // var n int = b // Error: cannot use b (type byte) as type int in assignment
  var n int = int(b) // 显式转换

for遍历语法： for index, value := range s

unsafe.Pointer(&x)：因为指针直接不能直接转换 所以要使用unsafe.Pointer(&x) 进行中转
         x := 0x12345678
         p := unsafe.Pointer(&x)   // *int -> unsafe.Pointer
         u := (*uint32)(p)         // unsafe.Pointer -> *uint32
         fmt.Printf("%x\n", *u)    // 0x12345678

在go 语言中 数组指针 访问其切片的时候 ，是访问的是值 而不是指针 是go语法反直觉的一个特性
          x := 0x12345678
          p := unsafe.Pointer(&x) // *int -> Pointer
          n := (*[4]byte)(p) // Pointer -> *[4]byte
          for i := 0; i < len(n); i++ {
          fmt.Printf("%X ", n[i]) // 78 56 34 12  ，注意 n[i]这里是解指针，很反直觉
          }

                                              |
