# **1️⃣ Container 的“包裹内容”能力是被动的**
* 它的尺寸完全依赖于 **父 Widget 的约束（constraints）**
## **2️⃣ 不同父约束的结果**
| 父约束类型                                          | Container 行为                                                       |
| ---------------------------------------------- | ------------------------------------------------------------------ |
| **无限约束（例如 Row/Column/ListView 主轴方向）**         | Container 尝试尽量小，但会受子 Widget layout 限制；复杂子 Widget 可能撑满 → 不能保证完全包裹内容 |
| **固定尺寸（SizedBox/ConstrainedBox 固定宽高）**         | Container 尺寸被固定 → 无法按内容收缩 |
| **最大约束有限（BoxConstraints(maxWidth/maxHeight)）** | Container 可以包裹内容，但不会超过父最大约束  |
| **无约束 （Center ，Align, Padding）/ 可伸缩父容器**      | Container 可以完美包裹内容 + padding  |

Flexible（默认 loose）不会自动压缩子组件 → 子太大 → 溢出。自动计算出剩余空间，给子组件添加最大尺寸约束。
Expanded / Flexible(tight) 会强制让子组件缩小到分配空间，但不是等比例缩放（而是给紧约束，让子自己适应）。
想“等比例缩小” → 别只靠 Flexible，要结合 FittedBox 等。
Row(
  children: [
    Icon(Icons.star),                    // 固定大小

    Flexible(                            // ← 这里用 Flexible，可以避免文字太长溢出，让ellipsis生效
      child: Text(
        "这是一个可能很长但不希望被强制拉伸的标题",
        overflow: TextOverflow.ellipsis,  // 文字太长时省略号
      ),
    ),

    Icon(Icons.more_horiz),
  ],
)

flutter根据子widget有的数目，分为三类基础布局widget，
LeafRenderObjectWidget（无child）：Text,Image，Icon
SingleChildRenderObjectWidget：Container,Padding，Align，Center，ConstrainedBox
MultiChildRenderObjectWidget：线性布局（Flex,Row,Column），流式布局(Wrap,Flow), 层叠布局(Stack)

constraints 组件约束，每个子组件都需要在父组件的约束下，确定自己的大小。
   一般子组件的大小是取父组件的约束和自己需求大小的交集。
flutter组件溢出的理解：组件溢出报错，只会发生在无法取约束交集，而且子组件超过了父组件 才会报溢出，如果可以取交集，自然不会溢出。

这些组件直接有 constraints 字段，可以对子组件大小进行约束：
组件	说明
ConstrainedBox	直接对单个子组件施加 BoxConstraints（min/max/固定宽高等）
UnconstrainedBox	 隔离父组件的约束，允许子组件突破父约束，自身大小会包裹子组件大小，通常用于做超出父容器大小的效果
SizedBox	通过 width / height / child 间接生成固定 BoxConstraints
AspectRatio	设置子组件的宽高比
FractionallySizedBox	子组件宽高按父容器百分比设置，内部会生成 constraints
LimitedBox	当父容器给无限约束时，限制子组件最大宽高
OverflowBox	子组件可以超出父约束范围，但内部会生成约束传递给子组件
SizedOverflowBox	给子组件一个可以超过自己大小的固定尺寸约束，但不改变自身大小（一般是父组件大小），常用于动画或子组件需要超出父组件显示
IntrinsicWidth / IntrinsicHeight	它会测量子组件的约束，然后根据子组件约束确定自身约束
Padding	虽然是间接作用，但内部会缩小对子组件的可用 constraints
ConstrainedBox 和 SizedBox，对子组件进行具体大小的约束

Row/Column 组件的主要属性有：
mainAxisSize （注意没有crossAxisSize,需要通过设置父组件大小来设置，交轴方向默认会匹配父组件大小）
mainAxisAlignment：主轴子组件对齐方式
crossAxisAlignment： 交轴子组件对齐方式
textDirection： 主轴方向的Alignment的start和end是左边还是右边（上面还是下面）
textBaseline：在交叉轴（vertical）方向上对齐文本的
verticalDirection: 和主轴方向垂直方向的排列方向。只有当 crossAxisAlignment设置为baseline 时，textBaseline才必须被指定，否则会报错。
                   TextBaseline.alphabetic， TextBaseline.ideographic

Row/Column 组件的 mainAxisAlignment 属性用于控制子Widget在主轴方向的的排列方式。
它的类型是枚举 `MainAxisAlignment`，一共有6种取值：
| 枚举值                              | 含义                                              |
| -------------------------------- | ----------------------------------------------- |
| `MainAxisAlignment.start`        | 子 Widget 靠左排列（主轴起点）                             |
| `MainAxisAlignment.end`          | 子 Widget 靠右排列（主轴终点）                             |
| `MainAxisAlignment.center`       | 子 Widget 居中排列                                   |
| `MainAxisAlignment.spaceBetween` | 子 Widget 之间的间距平均分配，首尾不留空                        |
| `MainAxisAlignment.spaceAround`  | 子 Widget 之间的间距平均分配，且每个子 Widget 前后间距相等（首尾也留一半间距） |
| `MainAxisAlignment.spaceEvenly`  | 子 Widget 之间的间距完全平均，包括首尾

Row/Column 的crossAxisAlignment控制的是交轴上子组件的排列方式，它的取值主要有以下几种：
| 值          | 说明                                        |
| ---------- | ----------------------------------------- |
| `start`    | 子组件在交叉轴起点对齐（上方）                           |
| `end`      | 子组件在交叉轴终点对齐（下方）                           |
| `center`   | 子组件在交叉轴居中对齐                               |
| `stretch`  | 子组件沿交叉轴拉伸，占满父组件高度（如果子组件没有固定高度）            |
| `baseline` | 按文字的基线对齐（仅对有文字的组件有效，需要 `textBaseline` 配合） |
* 默认值是 `CrossAxisAlignment.center`
* 对 `baseline` 对齐，需要 **所有子组件都有文本**，并且需要指定 `textBaseline`（`alphabetic` 或 `ideographic`）
* 如果父组件高度是固定的，而子组件高度固定或不可拉伸，`stretch` 会不起作用
   |


流式布局:Wrap、Flow
Row默认只有一行，如果超出屏幕不会折行。一般把超出屏幕显示范围会自动折行的布局称为流式布局。
Wrap({
  ...
  this.direction = Axis.horizontal,
  this.alignment = WrapAlignment.start,
  this.spacing = 0.0, // 主轴方向子widget的间距
  this.runAlignment = WrapAlignment.start, // 纵轴方向的对齐方式
  this.runSpacing = 0.0, // 纵轴方向的间距
  this.crossAxisAlignment = WrapCrossAlignment.start,
  this.textDirection,
  this.verticalDirection = VerticalDirection.down,
  List<Widget> children = const <Widget>[],
})
Flow：
一般很少会使用，因为需要自己实现子 widget 的位置转换。需要自定义子组件布局才使用。
使用Flow 一般自定义类继承FlowDelegate，重写getSize()，paintChildren()->以context.paintChild给子child layout

层叠布局（Stack、Positioned）
flutter的层叠布局和 Web 中的绝对定位、Android 中的 Frame 布局是相似的，子组件可以根据距父容器四个角的位置来确定自身的位置
Stack({
  this.alignment = AlignmentDirectional.topStart, // 子组件没有使用Positioned的时候的对齐方式
  this.textDirection,
  this.fit = StackFit.loose, // 确定没有使用Positioned的子组件，怎么根据约束类型（this.fit）确定自己的大小
  this.clipBehavior = Clip.hardEdge, // Stack边界之外的子Widget的裁剪方式
  List<Widget> children = const <Widget>[],
})
const Positioned({
  Key? key,
  this.left,
  this.top,
  this.right,
  this.bottom,
  this.width,
  this.height,
  required Widget child,
})
水平方向时，只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理

定位对齐类组件：Align, Center
Align({
  Key key,
  this.alignment = Alignment.center, // 需要 AlignmentGeometry 类型的对象，AlignmentGeometry是一个抽象类，它有两个常用的子类：Alignment和 FractionalOffset
  this.widthFactor, 缩放因子，乘以子元素的宽，最终的结果就是Align 组件的宽。如果值为null，则组件的宽高将会占用尽可能多的空间，如果小于1会约束子组件在在自己范围确定大小
  this.heightFactor,
  Widget child,
})
Alignment(x, y)：
Alignment(0,0) → 子元素放在父容器中心
Alignment(-1,-1) → 子元素放在父容器左上角
Alignment(1,1) → 子元素放在父容器右下角
Alignment(1,-1) → 子元素放在右上角
offsetX = (parentWidth - childWidth) / 2 * (x + 1)
offsetY = (parentHeight - childHeight) / 2 * (y + 1)

Container(
  height: 120.0,
  width: 120.0,
  color: Colors.blue[50],
  child: Align(
    alignment: FractionalOffset(0.2, 0.6),
    child: FlutterLogo(
      size: 60,
    ),
  ),
)
FractionalOffset 的公式原理
FractionalOffset(dx, dy) 表示 相对于父容器的比例位置：
dx = 0.0 → 子元素左边对齐父容器左边
dx = 1.0 → 子元素右边对齐父容器右边
dy = 0.0 → 子元素顶部对齐父容器顶部
dy = 1.0 → 子元素底部对齐父容器底部
偏移公式（简化版）：
offsetX = dx * (parentWidth - childWidth)
offsetY = dy * (parentHeight - childHeight)
注意这里 (parentWidth - childWidth)，是为了保证 dx = 1 时，子元素右边贴到父容器右边，不是说 dx = 1 时左上角坐标就是父宽度。

Center组件： 是Align的子类，是Align组件的阉割版，没有aliment属性，可以看作是Align组件固定了aliment=Alignment.center的属性
class Center extends Align {
  const Center({ Key? key,
  double widthFactor,
  double heightFactor,
  Widget? child
 })
    : super(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child);
}

LayoutBuilder组件：
可以在布局过程中拿到父组件传递的约束信息，然后我根据约束信息动态的构建布局
LayoutBuilder(builder: (BuildContext context, BoxConstraints constraints) {return Container()})

Padding组件：
Padding({
  ...
  EdgeInsetsGeometry padding,// EdgeInsetsGeometry是一个抽象类，开发中，我们一般都使用EdgeInsets类
  Widget child,
})
EdgeInsets提供的便捷方法：
fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的填充。
all(double value) : 所有方向均使用相同数值的填充。
only({left, top, right ,bottom })：可以设置具体某个方向的填充(可以同时指定多个方向)。
symmetric({ vertical, horizontal })：用于设置对称方向的填充，vertical指top和bottom，horizontal指left和right

DecoratedBox组件：给组件添加背景、前景，边框、渐变等装饰效果
const DecoratedBox({
  Decoration decoration, // Decoration是一个抽象类 ，一般使用子类 BoxDecoration
  DecorationPosition position = DecorationPosition.background, // background 或 foreground
  Widget? child
})
BoxDecoration({
  Color color, //颜色
  DecorationImage image,//图片
  BoxBorder border, //边框
  BorderRadiusGeometry borderRadius, //圆角
  List<BoxShadow> boxShadow, //阴影,可以指定多个
  Gradient gradient, //渐变
  BlendMode backgroundBlendMode, //背景混合模式
  BoxShape shape = BoxShape.rectangle, //形状
})

Transform组件：对子组件进行矩阵变换实现特效。
Container(
  color: Colors.black,
  child: Transform(
    alignment: Alignment.topRight, //相对于坐标系原点的对齐方式
    transform: Matrix4.skewY(0.3), //沿Y轴倾斜0.3弧度
    child: Container(
      child: const Text('Apartment for rent!'),
    ),
  ),
)
Transform.translate(offset: Offset(-20.0, -5.0),child: Text("Hello world"),) // 平移
Transform.rotate(angle:math.pi/2 ,child: Text("Hello world"),)  // 旋转
Transform.scale(scale: 1.5,child: Text("Hello world")) // 缩放

RotatedBox组件：
RotatedBox和Transform.rotate功能相似，它们都可以对子组件进行旋转变换，但是有不同：RotatedBox的变换是在layout阶段，会影响在子组件的位置和大小

Container组件：具有装饰（前景，背景），padding， margin，对齐方式，大小设置，变换功能
它本身不对应具体的RenderObject，它是DecoratedBox、ConstrainedBox、Transform、Padding、Align等组件组合的一个多功能容器
Container({
  this.alignment,
  this.padding, //容器内补白，属于decoration的装饰范围
  Color color, // 背景色
  Decoration decoration, // 背景装饰
  Decoration foregroundDecoration, //前景装饰
  double width,//容器的宽度
  double height, //容器的高度
  BoxConstraints constraints, //容器大小的限制条件
  this.margin,//容器外补白，不属于decoration的装饰范围
  this.transform, //变换
  this.child,
  ...
})
color和decoration是互斥的，如果同时设置它们则会报错！实际上，当指定color时，Container内会自动创建一个decoration

Clip组件：ClipOval, ClipRRect，ClipRect，ClipPath

FittedBox 组件： 对子组件进行裁剪，缩放以适配父组件大小。
  const FittedBox({
    super.key,
    this.fit = BoxFit.contain,
    this.alignment = Alignment.center,
    this.clipBehavior = Clip.none,
    super.child,
  })
fit	的七种取值
fill	拉伸子组件填满父容器，不保持比例，可能变形	子组件可能被压扁或拉长
contain	缩放（如果长宽都小于父组件，也可能放大）子组件以完全显示在父容器内，保持比例	宽高不超过父容器，可能留空白
cover	缩放子组件以覆盖父容器，保持比例	宽高至少覆盖父容器，可能裁剪
fitWidth	宽度填满父容器，高度按比例缩放	高度可能超出父容器
fitHeight	高度填满父容器，宽度按比例缩放	宽度可能超出父容器
scaleDown   仅在子组件比父容器大时缩小（只会缩小），否则保持原始大小
none	不缩放，使用子组件原始大小	超出父容器部分会溢出

滚动组件: SingleChildScrollView/ListView/SliverList: 底层最终都是基于 Scrollable + ViewPort + Sliver进行滚动的
只是SingleChildScrollView/ListView/GridView 明面上不需要传入Sliver 但是底层会把itemWidget都封装成Sliver进行滚动。
Scrollable： 复杂处理手势计算出每次需要滚动的距离和方向
Viewport： 可视窗口，窗口裁剪，滚动协调，回收与优化
Sliver：滚动内容切片；根据 scrollOffset 计算自身 geometry（scrollExtent、paintExtent、overflow）；负责绘制可见部分
Scrollable 内部封装了Viewport，Scrollable计算好要滚动的距离后，然后调用Viewport进行滚动ViewPort自己内部的Sliver

SingleChildScrollView组件： 少量Widget的时候使用
SingleChildScrollView({
  this.scrollDirection = Axis.vertical, //滚动方向，默认是垂直方向
  this.reverse = false,
  this.padding,
  bool primary,
  this.physics,
  this.controller,
  this.child,
})

ListView组件：
ListView({children:[]})： 没有懒加载机制
ListView.builder： 有懒加载机制
ListView.separated： 有懒加载机制，相比ListView.builder，可以配置分割线widget
ListView.custom：自定义 Sliver 子组件的列表，可以自己控制子组件的动态加载和回收缓存，可以控制每个ItemWidget的缓存策略，粒度比较细

class MyList extends StatelessWidget {
  const MyList({super.key});

  @override
  Widget build(BuildContext context) {
    return ListView.custom(
      childrenDelegate: SliverChildBuilderDelegate(
        (context, index) {
          // 每个子项用 KeepAlive 保留在缓存中
          return KeepAliveWidget(
            child: Container(
              height: 100,
              alignment: Alignment.center,
              color: index % 2 == 0 ? Colors.blue : Colors.green,
              child: Text('Item $index', style: const TextStyle(color: Colors.white, fontSize: 20)),
            ),
          );
        },
        childCount: 50,
        // 控制是否自动保持活跃状态（缓存）
        addAutomaticKeepAlives: true, // true// 是否允许子 Widget（如 KeepAliveWidget）发起的缓存请求生效
        addRepaintBoundaries: true,   // true 表示子组件单独绘制（渲染层面的缓存），提高性能
      ),
    );
  }
}