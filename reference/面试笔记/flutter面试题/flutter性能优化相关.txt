flutter列表滚动性能比原生android滚动性能差很多，flutter快速滚动还会导致白屏的原因：
android 拥有item View 复用机制，就是当ItemView被滚出可见窗口后，进入了回收池，当渲染新的ItemView的时候，只要ItemView类型相同，
就可以从回收池获取复用。
flutter没有itemView的回收复用机制而是只有缓存机制(viewport + cacheExtent 的短期缓存机制)，flutter缓存机制算法类似android图片内存缓存算法LRU（Least Recently Used），
缓存最近滚动的itemView。
因为flutter没有复用机制，导致了两个渲染弱点：
1. 所以无法支持脏显示（也就是新的内容显示前可以先显示渲染完毕的旧内容）
2. 如果没有缓存就需要重新渲染（element ，renderObject 都需要重新构建）
所以flutter滚动性能因为渲染机制的不同，flutter容易出现渲染不及时就白屏，flutter 滚动性能在大多数场景接近原生，但视觉连续性差.

---

flutterUI优化总纲：
flutter UI中有三颗树，widget树，element树，render object 树
要优化flutter UI的性能，就需要从这三棵树的缓存复用入手。
flutter中 三颗树的关系是： widget树是UI描述组件->element管理widget的挂载和卸载，以及把widget树的变化同步到renderObject->renderObject负责实际绘制

所以优化的角度可以从复用的层级深度来入手：
1. widget 级别的复用：const 修饰的widget，不会重复的创建widget对象，内存级别的复用，或者自己处理widget缓存复用逻辑（late final Widget）
                    推荐使用类widget，而不是普通函数中直接返回widget，因为普通函数中范围的widget树会让const widget内存复用失效。
2. element 级别的复用： widget会被频繁销毁重建，但是widget对应位置的element一直复用，因为element复用，element对应的renderObject也会复用
                     1.带有GlobalKey的widget可以跨节点复用element
                     2. 没有key的时候: widget的层级不变，类型不变，也会复用element
                     3. 如果有key的时候: widget的层级不变，类型不变，也会复用element，但是添加key ,可以让flutter框架直接通过可以比较key是否复用
                                       优点：Flutter 在 diff 时通过 Key 判断复用，更明确，不会因索引顺序变化导致错误复用.错误复用可能可能导致renderObject缓存失效
3.renderObject级别的复用： 官方API的widget层面 提供了 RepaintBoundary 进行了renderObject中的draw layer 复用优化

综上，除了const 修饰的widget和带有GlobalKey的widget可以跨节点复用element，其他的widget的element复用都无法跨节点复用，
也就是当widget父节点改变的时候，比如widget父节点类型改变，父节点element复用失败，都会导致该父节点的所有子节点需要重建，
所以在widget中，删除某层的widget，或者给widget树中间插入一个widget节点，会导致该widget对应的element下所有缓存节点失效，需要重新构建。



> **内存优化 / CPU 计算优化 / UI 渲染优化**

下面是**整理后的最终版本**（你可以直接拿去用在文档、面试、总结里）。
# Flutter App 性能优化三大类总结
## **一️⃣ UI 渲染优化（最核心、最常见）**

> 目标：**减少 rebuild / repaint / layer / raster 压力**

### 1. 布局与 Widget 构建优化

* **避免不必要的 rebuild**
  * 使用 `const` 构造函数
  * 不变化的子树使用 `StatelessWidget`
  ```dart
  const Text('Hello');
  ```
* **减少 Widget 嵌套**
  * 避免深层 `Column / Row / Stack`
  * 谨慎使用 `LayoutBuilder`、`IntrinsicWidth/Height`
### 2. Repaint 控制

* **合理使用 `RepaintBoundary`**
  * 隔离不常变化区域，避免整棵树重绘
  ```dart
  RepaintBoundary(child: MyComplexWidget());
  ```

### 3. 渲染层级与 GPU 负担

* **减少绘制层级**
  * 避免滥用 `Container`、`Opacity`、`ClipRRect`，能使用Padding的不要使用 Container
  * 简单装饰优先 `DecoratedBox`
* **减少透明层**
  * `Opacity` 会触发 offscreen rendering
  * 可用 `color.withOpacity` 替代
* **避免过度使用 Stack**
  * 优先 Row / Column / 自定义布局

### 4. 动画相关渲染优化

* 使用 `AnimatedBuilder` / `AnimatedWidget`
* 避免动画中全局 `setState`
* `Transform`、`Opacity` 利用 GPU compositing，优于频繁 layout

### 5. 页面与状态保持
* **页面切换用 `IndexedStack`**
  * 避免反复 rebuild

  ```dart
  IndexedStack(index: i, children: [...]);
  ```

---

## **二️⃣ CPU 计算优化（主 Isolate 负载控制）**

> 目标：**不阻塞 UI Isolate，不在 build 中做“脑力活”**

### 1. build 阶段计算控制

* ❌ 不在 `build` / `itemBuilder` 中做：

  * 排序
  * 过滤
  * 复杂数学计算
* ✅ 预计算 / 缓存 / memoization

### 2. 列表与滚动中的计算优化

* `ListView.builder / GridView.builder`
* 避免 `itemBuilder` 内 heavy 计算
* 滚动监听中避免高频 `setState`

  * 使用 throttle / debounce

### 3. Isolate 与并行计算

* 耗时计算放入子 Isolate

```dart
final result = await compute(expensiveFunction, data);
```

* UI Isolate 只负责：

  * 状态更新
  * 渲染

### 4. 动画与帧调度

* 使用 `Ticker / AnimationController`
* ❌ 不使用 `Timer + setState` 模拟逐帧刷新

---

## **三️⃣ 内存优化（对象 & GC 压力控制）**

> 目标：**减少对象创建频率，降低 GC 抖动**

### 1. Widget / 对象创建优化

* 使用 `const` Widget
* 避免 build 中创建大对象
* 复杂对象缓存或复用

### 2. 列表 Item 状态缓存

* 使用 `AutomaticKeepAliveClientMixin`

```dart
class _PageState extends State<Page>
    with AutomaticKeepAliveClientMixin {
  @override
  bool get wantKeepAlive => true;
}
```

### 3. 图片内存优化

* 使用合适分辨率（@1x/@2x/@3x）
* 控制解码尺寸：

```dart
Image.asset('img.png', cacheWidth: 200);
```

* 大图使用 `ResizeImage`
* 管理 `CachedNetworkImage` 缓存大小

### 4. 控制器与资源释放

* `dispose` 中释放：

  * `AnimationController`
  * `ScrollController`
  * `TextEditingController`

---

## **四️⃣ 调试与验证（三类优化的工具支撑）**

> 不直接算一类，但**是三类优化的前提**

* **Flutter DevTools**

  * CPU / GPU / Frame
  * Widget rebuild 追踪
  * 内存 & GC
* `debugRepaintRainbowEnabled`
* `PerformanceOverlay`
* Flutter Inspector（Widget 深度）

---
> **Flutter 性能优化的本质不是“算得快”，而是：**
> **少 build → 少 repaint → 不堵 UI Isolate → 少 GC**
